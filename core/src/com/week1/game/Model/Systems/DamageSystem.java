package com.week1.game.Model.Systems;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.utils.IntMap;
import com.week1.game.Model.Components.DamagingComponent;
import com.week1.game.Model.Components.HealthComponent;
import com.week1.game.Model.Components.UpgradeComponent;
import com.week1.game.Model.Events.DamageEvent;
import com.week1.game.Model.Events.DeathEvent;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

/*
 * System responsible for handling damage events.
 * Unlike other systems, it does not iterate over a list of nodes at every update.
 * Instead, it handles events generated by the TargetingSystem.
 * All events are handled in the update step.
 */
public class DamageSystem implements ISystem, Subscriber<DamageEvent>, Publisher<DeathEvent> {

    private ArrayList<Subscriber<DeathEvent>> deathSubscribers = new ArrayList<>();
    private Queue<DamageEvent> damageEvents = new ConcurrentLinkedQueue<>();
    private IntMap<HealthComponent> healthComponents = new IntMap<>();
    private IntMap<DamagingComponent> damagingComponents = new IntMap<>();
    private IntMap<UpgradeComponent> upgradeComponents = new IntMap<>();
    private IntMap<Integer> baseDamage = new IntMap<>();


    IService<Integer, Boolean> isCrystalService;
    IService<Integer, Boolean> isBaseService;

    @Override
    public void update(float delta) {
        for (DamageEvent damageEvent: damageEvents) {
            HealthComponent victimHealth = healthComponents.get(damageEvent.victimID);
            DamagingComponent damagingComponent = damagingComponents.get(damageEvent.damagerID);
            UpgradeComponent upgradeComponent = upgradeComponents.get(damageEvent.damagerPlayerID);

            Gdx.app.debug("DamageSystem", "Dealing Damage to " + damageEvent.victimID + " with current health " + victimHealth.curHealth);
            if (victimHealth.curHealth <= 0) continue; // Can't be dealt more damage below 0.
            if (!isCrystalService.query(damageEvent.victimID)){
                upgradeComponent.damageDealt += damagingComponent.baseDamage;
            }if (isBaseService.query(damageEvent.victimID)){
                int damageMultiplier = baseDamage.get(damageEvent.damagerPlayerID, 1);
                victimHealth.curHealth -= damagingComponent.baseDamage * damageMultiplier;
            } else {
                victimHealth.curHealth -= damagingComponent.baseDamage;
            }
            Gdx.app.debug("DamageSystem", "health now " + victimHealth.curHealth);
            if (victimHealth.curHealth <= 0) {
                // Inform death subscribers that a death has occurred.
                publish(DeathEvent.fromDamage(damageEvent));
            }
        }
        damageEvents.clear();
    }

    @Override
    public void remove(int entID) {
        healthComponents.remove(entID);
        damagingComponents.remove(entID);
    }

    public void addHealth(int entID, HealthComponent healthComponent) {
        healthComponents.put(entID, healthComponent);
    }

    public void addDamage(int entID, DamagingComponent damagingComponent) {
        damagingComponents.put(entID, damagingComponent);
    }

    public void addUpgrade(int playerID, UpgradeComponent upgradeComponent){upgradeComponents.put(playerID, upgradeComponent);}

    @Override
    public void process(DamageEvent damageEvent) {
        damageEvents.add(damageEvent);
    }

    @Override
    public void addSubscriber(Subscriber<DeathEvent> subscriber) {
        deathSubscribers.add(subscriber);
    }

    @Override
    public Collection<Subscriber<DeathEvent>> getSubscribers() {
        return deathSubscribers;
    }

    public void setIsCrystalService(IService<Integer, Boolean> isCrystalService) {
        this.isCrystalService = isCrystalService;
    }

    public void setIsBaseService(IService<Integer, Boolean> isBaseService){
        this.isBaseService = isBaseService;
    }

    public void baseDamage(Integer key, int i) {
        baseDamage.put(key, i);
    }

    public void baseDamage(boolean baseDamage){

    }
}
